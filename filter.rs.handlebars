use rpc_lib::rpc::Rpc;
use std::collections::HashMap;
use petgraph::algo::isomorphic_subgraph_matching;
use petgraph::graph::NodeIndex;
use graph_utils::graph_utils;

pub type CodeletType = fn(&Filter, &Rpc) -> Option<Rpc>;


// user defined functions:
{{#each udf_table}}{{{this.func_impl}}}{{/each}}


// This represents a piece of state of the filter
// it either contains a user defined function, or some sort of
// other persistent state
#[derive(Clone, Debug)]
pub struct State {
    pub type_of_state: Option<String>,
    pub string_data: Option<String>,
    {{#each udf_table}}pub udf_{{this.id}}: Option<{{this.struct_name}}>,{{/each}}
}

impl State {
    pub fn new() -> State {
        State {
            type_of_state: None,
            string_data: None,
            {{#each udfs_table}}udf_{{this.id}}:  None, {{/each}}
        }
    }

    pub fn new_with_str(str_data: String) -> State {
        State {
            type_of_state: Some(String::from("String")),
            string_data: Some(str_data),
            {{#each udf_table}}udf_{{this.id}}:  None, {{/each}}
        }
    }
}

#[derive(Clone, Debug)]
pub struct Filter {
    pub whoami: Option<String>,
    pub filter_state: HashMap<String, State>,
}

impl Filter {
    #[no_mangle]
    pub fn new() -> *mut Filter {
         Box::into_raw(Box::new(Filter {
            whoami: None,
            filter_state: HashMap::new(),
         }))
    }

    #[no_mangle]
    pub fn new_with_envoy_properties(string_data: HashMap<String, String>) -> *mut Filter {
        let mut hash = HashMap::new();
        for key in string_data.keys() {
            hash.insert(key.clone(), State::new_with_str(string_data[key].clone()));
        }
        Box::into_raw(Box::new(Filter { whoami: None, filter_state: hash }))
    }

    pub fn whoami(&mut self) {
        let my_node_wrapped = self
            .filter_state
            .get("node.metadata.WORKLOAD_NAME");
        if my_node_wrapped.is_none() {
            print!("WARNING: filter was initialized without envoy properties and thus cannot function");
            return;
        }
        let my_node = my_node_wrapped
            .unwrap()
            .string_data
            .clone()
            .unwrap();
        self.whoami = my_node;
    }

    pub fn add_myself_to_path(&mut self, x: &Rpc) -> String {
        if !x.headers.contains_key("path") {
            x.headers.insert(String::from("path"), String::from(self.whoami.clone()));
            x.headers.get_mut("path").unwrap().push_str(",");
        }
        else {
            x.headers.get_mut("path").unwrap().push_str(&String::from(self.whoami.clone()));
            x.headers.get_mut("path").unwrap().push_str(",");
        }
        return x.headers["path"];
    }

    //pub fn create_target_graph(&mut self) -> Graph {
    //}

    pub fn create_trace_graph(&mut self, mod_rpc: Rpc) -> Graph {
        let trace;
        if mod_rpc.headers.contains_key(&"properties".to_string()) {
            trace = graph_utils::generate_trace_graph_from_headers(mod_rpc.headers["path"].clone(), mod_rpc.headers.get_mut(&"properties".to_string()).unwrap().to_string());
        }
        else {
            trace = graph_utils::generate_trace_graph_from_headers(mod_rpc.headers["path"].clone(), String::new());
        }
        return trace;

    }

    pub fn on_incoming_requests(&mut self, x: &Rpc) {
        self.add_myself_to_path(x);
        return x;
    }

    pub fn on_incoming_responses(&mut self, x: &Rpc) {
        let path = self.add_myself_to_path(x);

        // at most, we return two rpcs:  one to continue on and one to storage
        let mut original_rpc = x.clone();
        let mut storage_rpc = None;

        /*
        self.execute_udfs(graph, thing);
        let target_graph = self.create_target_graph();
        let trace_graph = self.create_trace_graph(x);
        let mapping = isomorphic_subgraph_matching(
            &target_graph,
            &trace_graph,
            |x, y| {
                for property in y.1.keys() {
                    if x.1.contains_key(property) && &(x.1[property]) != &(y.1[property]) { return false; }
                }
            return true;
            },
            |x, y| x == y,
        );
        if !mapping.is_none() {
            let m = mapping.unwrap();
            let mut value = "0"; // dummy value
            // TODO: do return stuff
            let mut result_rpc = Rpc::new_rpc(&value);
            let mut dest = my_node.to_string().split("_").next().unwrap().to_string(); // do not take the _plugin affix
            dest.push_str("_storage");
            result_rpc
                .headers
                .insert("dest".to_string(), dest);
            result_rpc.headers.insert("src".to_string(), my_node);
            storage_rpc = Some(result_rpc);
       }

    }

    pub fn on_outgoing_requests(&mut self, x: &Rpc) {
        {{#each request_blocks}}{{{this}}} {{/each}}
        return x;
    }

    pub fn on_outgoing_responses(&mut self, x: &Rpc) {
        return x;
    }


    #[no_mangle]
    pub fn execute(&mut self, x: &Rpc) -> Vec<Rpc> {
        if self.whoami.is_none() { self.set_whoami(); }
        match rpc.headers["direction"] {
            "request" => {
                 match rpc.headers["location"] {
                 "ingress" => { return on_incoming_requests(x); }
                 "egress" => { return on_outgoing_requests(x); }
                 _ => panic!("Filter got an rpc with no location\n");
                 }
             }
             "response" => {
                 match rpc.headers["location"] {
                 "ingress" => { return on_incoming_responses(x); }
                 "egress" => { return on_outgoing_responses(x); }
                 _ => panic!("Filter got an rpc with no location\n");
             }
             _ => { panic!("Filter got an rpc with no direction\n"); }
        }
     
   
        let rpc_to_return = Rpc {
            data: x.data.clone(),
            uid: x.uid,
            path: x.path.clone(),
            headers: x.headers.clone(),
        };
        let mut to_return = vec![rpc_to_return];
        let mod_rpc = &mut to_return[0];


        // 5.  Pass the rpc on
        vec!(x)
    }

}
