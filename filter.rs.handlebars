use rpc_lib::rpc::Rpc;
use indexmap::map::IndexMap;
use petgraph::graph::NodeIndex;
use petgraph::Graph;
use petgraph::Incoming;
use graph_utils::utils;
use graph_utils::iso::find_mapping_shamir_centralized;
use serde::{Serialize, Deserialize};
extern crate serde_json;

pub type CodeletType = fn(&Filter, &Rpc) -> Option<Rpc>;


#[derive(Debug, Serialize, Deserialize)]
pub struct FerriedData {
    set_s: IndexMap<(NodeIndex, NodeIndex), IndexMap<NodeIndex, Option<Vec<(NodeIndex, NodeIndex)>>>>,
    trace_graph: Graph<(String, IndexMap<String, String>), String>,
    unassigned_properties: Vec<(String, String, String)>, // entity property value
}

impl FerriedData {
    fn default() -> FerriedData {
        FerriedData {
            set_s: IndexMap::new(),
            trace_graph: Graph::new(),
            unassigned_properties: Vec::new(),
            
        }
    }
}

// user defined functions:
{{#each udf_table}}{{{this.func_impl}}}{{/each}}


// This represents a piece of state of the filter
// it contains information that we get from calling getValue in the real filters
// TODO:  since we no longer use these to define UDFs, we have no need for it
// to be anything other than a string.  We should simplify it to simply have
// an Option<String> for every possible envoy value

#[derive(Clone, Debug)]
pub struct Filter {
    pub whoami: Option<String>,
    pub target_graph: Option<Graph<(String, IndexMap<String, String>), String>>,
    pub filter_state: IndexMap<String, String>,
    pub envoy_shared_data: IndexMap<String, String>, // trace ID to stored ferried data as string 
    pub collected_properties: Vec<String>, //properties to collect
}

impl Filter {
    #[no_mangle]
    pub fn new() -> *mut Filter {
         Box::into_raw(Box::new(Filter {
            whoami: None,
            target_graph: None,
            filter_state: IndexMap::new(),
            envoy_shared_data: IndexMap::<String, String>::new(),
            collected_properties: vec!( {{#each collected_properties}}"{{{this}}}".to_string(), {{/each}} ),
         }))
    }

    #[no_mangle]
    pub fn new_with_envoy_properties(string_data: IndexMap<String, String>) -> *mut Filter {
        Box::into_raw(Box::new(Filter {
                                   whoami: None,
                                   target_graph: None,
                                   filter_state: string_data,
                                   envoy_shared_data: IndexMap::new(),
                                   collected_properties: vec!({{#each collected_properties}}"{{{this}}}".to_string(), {{/each}} ),
                               }))
     }

    pub fn init_filter(&mut self) {
        if self.whoami.is_none() { self.set_whoami(); assert!(self.whoami.is_some()); }
        if self.target_graph.is_none() { self.create_target_graph(); } 
        assert!(self.whoami.is_some());
    }

    pub fn set_whoami(&mut self) {
        if !self.filter_state.contains_key("node.metadata.WORKLOAD_NAME") {
            print!("WARNING: filter was initialized without envoy properties and thus cannot function");
            return;
        }
        let my_node = self
            .filter_state["node.metadata.WORKLOAD_NAME"].clone();
        self.whoami = Some(my_node);
        assert!(self.whoami.is_some());
    }

    pub fn store_headers(&mut self, uid_64: u64, headers: IndexMap<String,String>) {
        // If you don't have data, nothing to store
        if headers.contains_key("ferried_data") { 
            print!("WARNING: no ferried data\n");
        }
        let uid = uid_64.to_string();
        // If there is no data stored, you needn't merge - just throw it in
        if !self.envoy_shared_data.contains_key(&uid) {
            self.envoy_shared_data.insert(uid.clone(), headers["ferried_data"].clone());
        }

        // Else, we merge in 3 parts, for each of the struct values
        let mut data: FerriedData;
        let mut stored_data: FerriedData;

        match serde_json::from_str(&headers["ferried_data"]) {
            Ok(d) => { data = d; }
            Err(e) => { print!("could not parse envoy shared data: {0}\n", e); return; }
        }
        match serde_json::from_str(&self.envoy_shared_data[&uid]) {
            Ok(d) => { stored_data = d; }
            Err(e) => { print!("could not parse envoy shared data: {0}\n", e); return; }
        }

        // 1. TODO: merge set_s

        // 2. Merge the graphs by simply adding it - later, when we merge, we will
        //    make a root

        // add node
        for node in data.trace_graph.node_indices() {
            stored_data.trace_graph.add_node(data.trace_graph.node_weight(node).unwrap().clone());
        }
        /*
        // add edges
        for edge in data.trace_graph.edge_indices() {
            let edge0_weight = data.trace_graph.node_weight(edge.0).unwrap();
            let edge1_weight = data.trace_graph.node_weight(edge.1).unwrap();
            let edge0_in_stored_graph = utils::get_node_with_id(&stored_data.trace_graph, edge0_weight);
            let edge1_in_stored_graph = utils::get_node_with_id(&stored_data.trace_graph, edge1_weight);
            stored_data.trace_graph.add_edge(edge0_in_stored_graph, edge1_in_stored_graph, String::new());
        }
        */

        // 3. merge unassigned properties
        //    these are properties we have collected but are not yet in the graph
        stored_data.unassigned_properties.append(&mut data.unassigned_properties);
        stored_data.unassigned_properties.sort_unstable();
        stored_data.unassigned_properties.dedup();

        match serde_json::to_string(&stored_data) {
            Ok(stored_data_string) => {
                self.envoy_shared_data.insert(uid, stored_data_string);
            }
            Err(e) => {
                print!("ERROR:  could not translate stored data to json string: {0}\n", e);
            }
        }

    }

    pub fn merge_headers(&mut self, uid: u64, mut new_rpc_headers: IndexMap<String, String>) -> IndexMap<String, String> {
        let uid_str = uid.to_string();
        let mut my_indexmap = IndexMap::new();
        my_indexmap.insert("node.metadata.WORKLOAD_NAME".to_string(), self.whoami.as_ref().unwrap().clone());

        if self.envoy_shared_data.contains_key(&uid_str) {
            match serde_json::from_str(&self.envoy_shared_data[&uid_str]) {
                Ok(d) => {
                    // 1. TODO:  if needed, do things to set S
                    // 2. Add yourself as root
                    let mut data: FerriedData = d;
                    let mut previous_roots = Vec::new();
                    for node in data.trace_graph.node_indices() {
                        if data.trace_graph.neighbors_directed(node, Incoming).count() == 0 {
                            previous_roots.push(node);
                        }
                    }
                    let me = data.trace_graph.add_node((self.whoami.as_ref().unwrap().to_string(), my_indexmap));

                    for previous_root in previous_roots {
                        data.trace_graph.add_edge(me, previous_root, String::new());
                    }
                    match serde_json::to_string(&data) {
                        Ok(stored_data_string) => {
                            new_rpc_headers.insert("ferried_data".to_string(), stored_data_string);
                        }
                        Err(e) => {
                            print!("ERROR:  could not translate stored data to json string: {0}\n", e);
                        }
                    }
                }
                Err(e) => {
                    print!("ERROR:  could not parse envoy shared data: {0}\n", e);
                }

            }
        } else {
            // just add yourself as root
            let mut new_ferried_data = FerriedData::default();
            new_ferried_data.trace_graph.add_node((self.whoami.as_ref().unwrap().to_string(), my_indexmap));
            new_rpc_headers.insert("ferried_data".to_string(), self.envoy_shared_data[&uid_str].clone());
            match serde_json::to_string(&new_ferried_data) {
                Ok(stored_data_string) => {
                    new_rpc_headers.insert("ferried_data".to_string(), stored_data_string);
                }
                Err(e) => {
                    print!("ERROR:  could not translate stored data to json string: {0}\n", e);
                }
            }

        }
        return new_rpc_headers;
    }

    pub fn create_target_graph(&mut self) {
        {{#each target_blocks}}{{{this}}} {{/each}}
    }

    pub fn create_trace_graph(&mut self, mut mod_rpc: Rpc) -> Graph<(String, IndexMap<String, String>), String> {
        let trace;
        let mut path = mod_rpc.headers["properties_path"].clone();
        let mut properties = Vec::new();
        for header in mod_rpc.headers.keys() {
            if header.contains("properties_") && header != "properties_path" {
                properties.push(mod_rpc.headers[header].clone().replace("properties_", ""));
            }
        }
        let prop_to_trace = properties.join(",");
        trace = utils::generate_trace_graph_from_headers(path, prop_to_trace);
        return trace;
    }

    pub fn on_incoming_requests(&mut self, mut x: Rpc) -> Vec<Rpc> {
        let mut prop_str;
        {{#each request_blocks}}{{{this}}} {{/each}}
        self.store_headers(x.uid, x.headers.clone());
        return vec!(x);
    }

    pub fn on_outgoing_responses(&mut self, mut x: Rpc) -> Vec<Rpc> {
        x.headers = self.merge_headers(x.uid, x.headers);

        // at most, we return two rpcs:  one to continue on and one to storage
        let mut original_rpc = x.clone();
        let mut storage_rpc : Option<Rpc> = None;

        if !original_rpc.headers.contains_key("ferried") {
            match serde_json::to_string(&FerriedData::default()) {
                Ok(ferried_data_string) => {
                    original_rpc.headers.insert("ferried_data".to_string(), ferried_data_string);
                }
                Err(e) => {
                    print!("ERROR:  ferried data could not be turned to a string: {0}\n", e);
                    return vec![original_rpc];
                }
            }
        }
        let mut trace_graph = self.create_trace_graph(x.clone());

        /*
        // calculate UDFs and store result, and check trace level properties
        {{#each udf_blocks}}{{{this}}} {{/each}}

        let mapping = find_mapping_shamir_centralized(
            &trace_graph,
            self.target_graph.as_ref().unwrap(),
        );
        if mapping.is_some() {
            let m = mapping.unwrap();
            let mut value : String;
            // TODO: do return stuff
            {{#each response_blocks}}{{{this}}} {{/each}}
            let mut result_rpc = Rpc::new_with_src(&value, self.whoami.as_ref().unwrap());
            result_rpc
                .headers
                .insert("dest".to_string(), "storage".to_string());
            result_rpc
                .headers
                .insert("direction".to_string(), "request".to_string());
            result_rpc.headers.insert("src".to_string(), self.whoami.clone().unwrap());
            storage_rpc = Some(result_rpc);
            return vec!(x, storage_rpc.unwrap());
       }
       */
       return vec!(x);

    }

    pub fn on_outgoing_requests(&mut self, mut x: Rpc) -> Vec<Rpc>{
        x.headers = self.merge_headers(x.uid, x.headers);
        return vec!(x);
    }

    pub fn on_incoming_responses(&mut self, mut x: Rpc) -> Vec<Rpc> {
        self.store_headers(x.uid, x.headers.clone());
        return vec!(x);
    }


    #[no_mangle]
    pub fn execute(&mut self, x: &Rpc) -> Vec<Rpc> {
        self.init_filter();
        assert!(self.whoami.is_some());
        match x.headers["direction"].as_str() {
            "request" => {
                 match x.headers["location"].as_str() {
                 "ingress" => { return self.on_incoming_requests(x.clone()); }
                 "egress" => { return self.on_outgoing_requests(x.clone()); }
                 _ => { panic!("Filter got an rpc with no location\n"); }
                 }
             }
             "response" => {
                 match x.headers["location"].as_str() {
                 "ingress" => { return self.on_incoming_responses(x.clone()); }
                 "egress" => { return self.on_outgoing_responses(x.clone()); }
                 _ => { panic!("Filter got an rpc with no location\n"); }
                 }
             }
             _ => { panic!("Filter got an rpc with no direction\n"); }
        }
    }

}
