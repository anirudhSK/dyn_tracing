use rpc_lib::rpc::Rpc;
use std::collections::HashMap;
use std::fs::OpenOptions;
use std::io::Write;
use petgraph::algo::isomorphic_subgraph_matching;
use petgraph::graph::NodeIndex;
use graph_utils::graph_utils;

pub type CodeletType = fn(&Filter, &Rpc) -> Option<Rpc>;


// user defined functions:
{{#each rust_udfs}}{{{this.func_impl}}}{{/each}}


// This represents a piece of state of the filter
// it either contains a user defined function, or some sort of
// other persistent state
#[derive(Clone, Debug)]
pub struct State {
    pub type_of_state: Option<String>,
    pub string_data: Option<String>,
    {{#each rust_udfs}}pub udf_{{this.id}}: Option<{{this.struct_name}}>,{{/each}}
}

impl State {
    pub fn new() -> State {
        State {
            type_of_state: None,
            string_data: None,
            {{#each rust_udfs}}udf_{{this.id}}:  None, {{/each}}
        }
    }

    pub fn new_with_str(str_data: String) -> State {
        State {
            type_of_state: Some(String::from("String")),
            string_data: Some(str_data),
            {{#each rust_udfs}}udf_{{this.id}}:  None, {{/each}}
        }
    }
}

#[derive(Clone, Debug)]
pub struct Filter {
    pub filter_state: HashMap<String, State>,
}

impl Filter {
    #[no_mangle]
    pub fn new() -> *mut Filter {
         Box::into_raw(Box::new(Filter {
            filter_state: HashMap::new(),
         }))
    }

    #[no_mangle]
    pub fn new_with_envoy_properties(string_data: HashMap<String, String>) -> *mut Filter {
        let mut hash = HashMap::new();
        for key in string_data.keys() {
            hash.insert(key.clone(), State::new_with_str(string_data[key].clone()));
        }
        Box::into_raw(Box::new(Filter { filter_state: hash }))
    }

    #[no_mangle]
    pub fn execute(&mut self, x: &Rpc) -> Vec<Rpc> {
     let rpc_to_return = Rpc {
            data: x.data.clone(),
            uid: x.uid,
            path: x.path.clone(),
            headers: x.headers.clone(),
        };
        let mut to_return = vec![rpc_to_return];
        let mod_rpc = &mut to_return[0];

        // 0. Who am I, what is my path so far?
        let my_node_wrapped = self
            .filter_state
            .get("node.metadata.WORKLOAD_NAME");
        if my_node_wrapped.is_none() {
            print!("WARNING: filter was initialized without envoy properties and thus cannot function");
            return to_return;
        }
        let my_node = my_node_wrapped
            .unwrap()
            .string_data
            .clone()
            .unwrap();

        // add ourselves to the path now that we are done
        if !self.filter_state.contains_key("path") {
            if !mod_rpc.headers.contains_key("path") {
                mod_rpc.headers.insert(String::from("path"), String::from(my_node.clone()));
                mod_rpc.headers.get_mut("path").unwrap().push_str(",");
            }
            else {
                mod_rpc.headers.get_mut("path").unwrap().push_str(&String::from(my_node.clone()));
                mod_rpc.headers.get_mut("path").unwrap().push_str(",");

            }
        }

        // 1. Do I need to put any udf variables/objects in?
        {{#each rust_udfs}}
        if !self.filter_state.contains_key("{{this.id}}") {
            let mut new_state = State::new();
            new_state.type_of_state = Some(String::from("{{this.id}}"));
            new_state.udf_{{this.id}} = Some({{this.struct_name}}::{{this.init_func}}());
            self.filter_state.insert(String::from("{{this.id}}"), new_state);
        }
        {{/each}}

        // 2. Include any relevant node attributes
        let mut data_to_append: String;
        let mut data_key: String;
        let mut me;
        {{#each node_attributes_to_fetch}}

        me = my_node.clone();
        me.push_str(".");

        data_key = vec![ {{#each this.parts}} String::from("{{this}}"), {{/each}} ].join(".");
        data_to_append = self.filter_state[&data_key].string_data.as_ref().unwrap().to_string();
        me.push_str(&data_key);
        me.push_str("==");
        me.push_str(&data_to_append);
        me.push_str(",");

        if mod_rpc.headers.contains_key(&"properties".to_string()) {
            mod_rpc.headers.get_mut(&"properties".to_string()).unwrap().push_str(&me);
        }
        else {
            mod_rpc.headers.insert("properties".to_string(), me);
        }
        
        {{/each}}

        // 3.  Make a subgraph representing the query, check isomorphism compared to the
        //     observed trace, and do return calls based on that info
        if my_node == String::from("{{root_id}}") {
            // we need to create the graph given by the query
            let vertices = vec![ {{#each vertices}}String::from("{{this}}"), {{/each}}  ];
            let edges = vec![ {{#each edges}} ( {{#each this}}String::from("{{this}}"), {{/each}} ), {{/each}} ];
            // ids_to_properties is a HashMap taking <(NodeName, Properties), Desired Value>, so if the query says
            // a.service_name == productpagev1"
            // in ids_to_properties we have
            // ids_to_properties("a", { node.metadata.WORKLOAD_NAME = "productpage-v1" } )
            let mut ids_to_properties: HashMap<String, HashMap<String, String>> = HashMap::new();
            {{#each vertices}} ids_to_properties.insert("{{this}}".to_string(), HashMap::new()); {{/each}}

            {{#each nodes_to_attributes}}
            let mut {{this.id}}_property_hashmap = HashMap::new();
            {{this.id}}_property_hashmap.insert(vec! [ {{#each this.parts}} String::from("{{this}}"), {{/each}} ].join("."), "{{this.value}}".to_string());
            ids_to_properties.insert("{{this.id}}".to_string(), {{this.id}}_property_hashmap.clone());
            {{/each}}

            let target = graph_utils::generate_target_graph(vertices, edges, ids_to_properties);
            let trace;
            if mod_rpc.headers.contains_key(&"properties".to_string()) {
                trace = graph_utils::generate_trace_graph_from_headers(mod_rpc.headers["path"].clone(), mod_rpc.headers.get_mut(&"properties".to_string()).unwrap().to_string());
            }
            else {
                trace = graph_utils::generate_trace_graph_from_headers(mod_rpc.headers["path"].clone(), String::new());

            }
            let mapping = isomorphic_subgraph_matching(
                &target,
                &trace,
                |x, y| {
                    for property in y.1.keys() {
                        if property != &"node.metadata.WORKLOAD_NAME".to_string() && &(x.1[property]) != &(y.1[property]) { return false; }
                    }
                return true;
                },
                |x, y| x == y,
            );
            if !mapping.is_none() {
                let m = mapping.unwrap();
                // In the non-simulator version, we will send the result to storage.  Given this is
                // a simulation, we will write it to a file for now
                // TODO:  make a storage node in the simulator
                {{#each rust_blocks}}{{{this}}}{{/each}}

                {{#with result}}
                {{#if this.Return}}{{#with this.Return}}

                {{/with}}{{/if}}
                {{/with}}



            }
        }


        // 5.  Pass the rpc on
        to_return
    }

}
