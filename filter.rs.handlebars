mod graph_utils;

use rpc_lib::rpc::Rpc;
use std::collections::HashMap;
use std::fs;
use petgraph::algo::isomorphic_subgraph_matching;
use petgraph::graph::NodeIndex;

pub type CodeletType = fn(&Filter, &Rpc) -> Option<Rpc>;


// user defined functions:
{{#each rust_udfs}}{{{this.func_impl}}}{{/each}}


// This represents a piece of state of the filter
// it either contains a user defined function, or some sort of
// other persistent state
#[derive(Clone, Debug)]
pub struct State {
    pub type_of_state: Option<String>,
    pub string_data: Option<String>,
    {{#each rust_udfs}}pub udf_{{this.id}}: Option<{{this.struct_name}}>,{{/each}}
}

impl State {
    pub fn new() -> State {
        State {
            type_of_state: None,
            string_data: None,
            {{#each rust_udfs}}udf_{{this.id}}:  None, {{/each}}
        }
    }

    pub fn new_with_str(str_data: String) -> State {
        State {
            type_of_state: Some(String::from("String")),
            string_data: Some(str_data),
            {{#each rust_udfs}}udf_{{this.id}}:  None, {{/each}}
        }
    }
}

#[derive(Clone, Debug)]
pub struct Filter {
    pub filter_state: HashMap<String, State>,
}

impl Filter {
    #[no_mangle]
    pub fn new() -> *mut Filter {
         Box::into_raw(Box::new(Filter {
            filter_state: HashMap::new(),
        }))
    }

    #[no_mangle]
    pub fn new_with_envoy_properties(string_data: HashMap<String, String>) -> *mut Filter {
        let mut hash = HashMap::new();
        for key in string_data.keys() {
            hash.insert(key.clone(), State::new_with_str(string_data[key].clone()));
        }
        Box::into_raw(Box::new(Filter { filter_state: hash }))
    }

    #[no_mangle]
    pub fn execute(&mut self, x: &Rpc) -> Option<Rpc> {
        // 0. Who am I?
        let my_node_wrapped = self
            .filter_state
            .get("node.metadata.WORKLOAD_NAME");
        if my_node_wrapped.is_none() {
            print!("WARNING: filter was initialized without envoy properties and thus cannot function");
            return Some(Rpc {
                       data: x.data,
                       uid: x.uid,
                       path: x.path.clone(),
                   });
        }
        let my_node = my_node_wrapped
            .unwrap()
            .string_data
            .clone()
            .unwrap();


        // 1. Do I need to put any udf variables/objects in?
        {{#each rust_udfs}}
        if !self.filter_state.contains_key("{{this.id}}") {
            let mut new_state = State::new();
            new_state.type_of_state = Some(String::from("{{this.id}}"));
            new_state.udf_{{this.id}} = Some({{this.struct_name}}::{{this.init_func}}());
            self.filter_state.insert(String::from("{{this.id}}"), new_state);
        }
        {{/each}}

        // 2. TODO: Find the node attributes to be collected

        // 3.  Make a subgraph representing the query, check isomorphism compared to the
        //     observed trace, and do return calls based on that info
        if my_node == String::from("{{root_id}}") {
            // we need to create the graph given by the query
            let vertices = vec![ {{#each vertices}}String::from("{{this}}"), {{/each}}  ];
            let edges = vec![ {{#each edges}} ( {{#each this}}String::from("{{this}}"), {{/each}} ), {{/each}} ];
            // ids_to_properties is a HashMap taking <(NodeName, Properties), Desired Value>, so if the query says
            // a.service_name == productpagev1"
            // in ids_to_properties we have
            // ids_to_properties("a", { node.metadata.WORKLOAD_NAME = "productpage-v1" } )
            let mut ids_to_properties: HashMap<String, HashMap<String, String>> = HashMap::new();
            {{#each nodes_to_attributes}}
            let properties = vec! [ {{#each this.parts}} String::from("{{this}}"), {{/each}} ].join(".");
            {{/each}}

            {{#each vertices}}
            let mut {{this}}_hashmap = HashMap::new();
            {{this}}_hashmap.insert(properties.clone(), "{{this}}".to_string());
            ids_to_properties.insert("{{this}}".to_string(), {{this}}_hashmap);
            {{/each}}


            let target_graph = graph_utils::generate_target_graph(vertices, edges, ids_to_properties);
            let trace_graph = graph_utils::generate_trace_graph_from_headers(x.path.clone());
            let mapping = isomorphic_subgraph_matching(
                &target_graph,
                &trace_graph,
                |x, y| {
                    for property in y.1.keys() {
                        if property != &"node.metadata.WORKLOAD_NAME".to_string() && &(x.1[property]) != &(y.1[property]) { return false; }
                    }
                return true;
                },
                |x, y| x == y,
            );
            if !mapping.is_none() {
                let m = mapping.unwrap();
                // In the non-simulator version, we will send the result to storage.  Given this is
                // a simulation, we will write it to a file.
                {{#each rust_blocks}}{{{this}}}{{/each}}
                {{#each rust_udfs}}
                let {{this.id}}_state_ptr = self.filter_state.get_mut("{{this.id}}").unwrap();
                let {{this.id}}_obj_ptr = {{this.id}}_state_ptr.udf_{{this.id}}.as_mut().unwrap();
                let {{this.id}}_value = {{this.id}}_obj_ptr.execute().to_string();

                fs::write("result.txt", {{this.id}}_value).expect("Unable to write file");

                {{/each}}

            }
        }
        // 4.  Allow udfs to execute
        {{#each rust_udfs}}
        let {{this.id}}_state_ptr = self.filter_state.get_mut("{{this.id}}").unwrap();
        let {{this.id}}_obj_ptr = {{this.id}}_state_ptr.udf_{{this.id}}.as_mut().unwrap();
        {{this.id}}_obj_ptr.execute();
        {{/each}}


        // 5.  Pass the rpc on
        Some(Rpc{
            data: x.data, uid: x.uid , path: x.path.clone()
             }   )
    }

}
